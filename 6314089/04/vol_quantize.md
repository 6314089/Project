#vol_quantize.mについて

元のデータとフレーム幅を入れて，音量に関係する値のデータ群を返す関数．


##vol_quantize.mで何をやろうとしているか
下のグラフは[plot_wav.m](/6314089/04/plot_wav.m)で出力したもの．

![img0](/6314089/04/img/0.png)

このグラフでは一番左が/6314089/Audio/drums_120bpm.wavを`audioread`したデータをそのままプロットしたもの．

wavファイルを`audioread`すると，そのデータは各サンプリングでの振幅的なのが並んだものになる．サンプリングレートは44.1kHzなので，1秒間を44100個に分割して，その一個一個での大きさを順番に並べていったようなデータが出てくる．

    >> [data, Fs] = audioread('../Audio/drums_120bpm.wav');
    >> data(1:10)

    ans =

       1.0e-03 *

        0.1221   -0.1221    0.1831   -0.2136    0.3967   -0.0305    0.0305   -0.0305    0.0305   -0.0610

上は出てきたデータの1から10番目を出力してみた例．

振幅というのは音量と関係のあるデータなので，基本的にはこの振幅を見ればいい．
ただし，audioreadしたデータをそのまま見るだけでは上手く行かないかもしれない．

グラフの右の方のは左のグラフを拡大したもの．
拡大してみるとメッチャ細かく振動しているのが分かる．
音量がメッチャ短い時間で変化しまくっているわけだけど，
このデータを見て音量の変化を探ろうとしても上手く行かない．

そこで，ある程度の区間ずつに区切って，その中の値を全部足すことで扱いやすいデータにしようとしている．量子化みたいな感じ？

![img1](/6314089/04/img/1.png)

##コードの中身

    function vol = vol_quantize(data, N)
        ndata = length(data);
        K = floor(ndata / N);

        vol = zeros(1, K);
        for k = 1:K
            a = N * (k-1) + 1;
            b = min(N * k, ndata);
            frame_data = data(a:b);
            vol(k) = sqrt(sum(frame_data .* frame_data) / N);
        end

引数の`data`が生データ．
`N`はフレームのサンプル数．生データを`N`個ずつに分けて，それらの中で足し合わせることになる．

返り値`vol`は，量子化した後の音量のデータが並んだベクトルとなる．

生データのサンプル数が`ndata`で，
`K`が足し合わせた後の数．`ndata`を`N`で割って切り捨てにしている．
右端の余った部分は無視して捨てている．

`vol`は`K`個のベクトルとなる．最初に`zeros`で1行`K`列の0で埋まったベクトルを初期値として用意している．

`a`と`b`が`k`番目のフレームの最初と最後の生データでの位置．
`k`が1から始まっているので0から始まっていたCやJavaとはちょっと違う．
`b`はなんか余計なことをやっているけれども，これは`K`を切り捨てにしていなかった頃の名残．`b`は`N * K`になっている．

このフレームで切り取られるデータは生データの`a`番目から`b`番目である．
切り取ったフレーム内のデータを`frame_data`としている．
`data(a:b)`というのは`data`の`a`番目から`b`番目を並べたベクトルになってる．

そのフレームデータについて二乗和を取ってるのかな．その結果をvolのk番目に入れている．

##実行結果

    >> [data, Fs] = audioread('../Audio/drums_120bpm.wav');
    >> vol = vol_quantize(data, 4410);
    >> plot(vol)
    >> plot(vol(1:30))

ドラム音源を読み込んで，1フレームを4410サンプルにしてボリュームの列を求めてる．
プロットした結果は以下のようになってる．

![img2](/6314089/04/img/2.png)

![img3](/6314089/04/img/3.png)

4410個づつに区切って集めているので生データのような振動しまくっていたのとは違って扱いやすいデータになっているのではないか．

1フレームの長さをどうするかとかそういうのを考えてみるといいかもしれない．

ドラム音源なので音量の上下が激しいけれども，他のだとどうなのかな．
