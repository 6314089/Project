#vol_quantize.mについて

元のデータとフレーム幅を入れて，音量に関係する値のデータ群を返す関数．


##vol_quantize.mで何をやろうとしているか
下のグラフは[plot_wav.m](/6314089/04/plot_wav.m)で出力したもの．

![img0](/6314089/04/img/0.png)

このグラフでは一番左が/6314089/Audio/drums_120bpm.wavを`audioread`したデータをそのままプロットしたもの．

wavファイルを`audioread`すると，そのデータは各サンプリングでの振幅的なのが並んだものになる．サンプリングレートは44.1kHzなので，1秒間を44100個に分割して，その一個一個での大きさを順番に並べていったようなデータが出てくる．

    >> [data, Fs] = audioread('../Audio/drums_120bpm.wav');
    >> data(1:10)

    ans =

       1.0e-03 *

        0.1221   -0.1221    0.1831   -0.2136    0.3967   -0.0305    0.0305   -0.0305    0.0305   -0.0610

上は出てきたデータの1から10番目を出力してみた例．

振幅というのは音量と関係のあるデータなので，基本的にはこの振幅を見ればいい．
ただし，audioreadしたデータをそのまま見るだけでは上手く行かないかもしれない．

グラフの右の方のは左のグラフを拡大したもの．
拡大してみるとメッチャ細かく振動しているのが分かる．
音量がメッチャ短い時間で変化しまくっているわけだけど，
このデータを見て音量の変化を探ろうとしても上手く行かない．

そこで，ある程度の区間ずつに区切って，その中の値を全部足すことで扱いやすいデータにしようとしている．量子化みたいな感じ？

![img1](/6314089/04/img/1.png)
