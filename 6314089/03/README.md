#03
音源の基音と倍音データをもとに違う音高の音を分離することを目指す．

解析するのは楽音とする．つまり，基音とその倍音成分がわかれば音がわかるようなもの．
基音と倍音の成分の周波数と，その周波数での振幅及び位相をデータとして抽出する．
そのデータをもとに音を復元してみる．

異なるキーの楽音が同時になっている場合，異なるキーの基音と倍音が検出できる．

基音と倍音の検出は，fftでスペクトル解析した結果の極大値を取る部分を見ることで行う．
基音と倍音成分以外は存在しないものとすると，findpeaksで取ってきた極大値の部分が基音と倍音の部分に当たるはず．
fftの結果は複素数の列になっていて，その複素数がその周波数での振幅と位相のデータになっている．複素数の絶対値が振幅の大きさで，その複素数の偏角が位相らしい．
http://www.asp.c.dendai.ac.jp/courses/basic/kihon_spectrum01.pdf

基音と倍音の周波数のデータを，周波数でキーごとに振り分けて，
それから，各キーごとにデータをもとに元の音を復元してみる．

##get_A
A0とその2倍音，3倍音，…の周波数を22050Hzまで並べたベクトルを返す．

`[27.5 55 82.5 110 ...]`みたいなのが返ってくる．A0は27.5Hz．A4=440Hzの2の4乗分の一．440*(1/16) = 27.5．

##A_frequencies
入力した音をfftにかけて，そのピーク部分のうちA0の倍音の成分を抽出する．

引数は音源のファイル名．key Aの音でないと意味が無いはず．

返り値は1次のベクトル．
返り値を`[y1 y2 y3 y4 ...]`とすると，`y1`は27.5Hzの部分，`y2`は55Hzの部分，`y3`は82.5Hzの部分…．

    function ret = A_frequencies(filename)
        %read file
        [input, Fs] = audioread(filename);

        %fft
        m = length(input); %window length
        n = 2^nextpow2(m);
        Y = fft(input, n);

        %get peek frequencies and length
        [~, locs] = findpeaks(abs(Y), 'MinPeakProminence', 2500);
        peekfs = (locs-1)*(Fs/n); %turn locs into "0 start" and into frequencies
        npeekfs = ceil(length(peekfs)/2);

        %get key A frequencies and length
        Afs = get_A;
        nAfs = length(Afs);

        %fill return value with 0
        ret = zeros(1, length(Afs));

        %10cents
        threshold = nthroot(2, 12*10);    


        for i = 1:nAfs
            Af = Afs(i);
            for j = 1:npeekfs
                f= peekfs(j);
                if (Af >= f && Af / f <= threshold) ||...
                    (Af < f && f / Af <= threshold) %+-10cents
                   ret(i) = Y(locs(j));
                end
            end
        end

fftの高速化のためにサンプルを2のべき乗個になるようにしてる．
[02](/6314089/02/README.md)でも同じことをやってる．  
https://jp.mathworks.com/help/matlab/math/fast-fourier-transform-fft.html

`findpeaks`でよくわからずプロミネンスとかいうのを使っているのも02と同じ．

`peekfs`は`findpeaks`で取ってきたピークの場所を周波数に変換したもの．
後半の部分は鏡像で役立たずらしいので前半の部分だけを使うために`npeeks`は`peeks`の長さを2で割って切り上げたものにしてる．

fftかけたものをfindpeaksする前に半分に切り取ったほうがいい気もしてきた．

get_Aは上で説明したとおり．

for文で，
ピークの周波数とA0の倍音周波数が一致する部分についてのみ，
fftの結果の`Y`を返り値のベクトルに入れている．
`Afs`には`get_A`の返り値として22050Hz以下のA0の倍音が順番に入っている．
`Af`はA0の倍音の一つということになる．
それと，ピークの周波数が一致するかどうかを確認し，
一致したものについては，そのfftの結果を返り血に入れている．

周波数が一致するかどうかの判定には閾値10セントとした．
±(半音の1/10)だったときは同じ音だと判定している．
半音の1/10は周波数の比が2の120乗根以内になっているかどうかを見れば良い．

人間には音の高さと周波数は等比数列的に聞こえる．
周波数が2倍になると1オクターブ上がるので，1オクターブを12等分するには，隣り合う音の周波数の比が2の12乗根になるようにする．
これが12平均律での音の決め方．

12平均律での半音の差を100セントというらしい．
±10セント以内であるかを考えるならば，周波数の比が2の120乗根倍以内になっているかどうかを考えれば良いことになる．


実行結果

    >> a4saw = A_frequencies('../Audio/A4_saw.wav')

    a4saw =

       1.0e+04 *

      1 列から 5 列

       0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i

      6 列から 10 列

       0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i

      11 列から 15 列

       0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i

      16 列から 20 列

       1.3562 + 2.3062i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i

      21 列から 25 列

       0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i

      26 列から 30 列

       0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i

      31 列から 35 列

       0.0000 + 0.0000i  -1.0074 + 0.5768i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i

      36 列から 40 列

       0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i

      41 列から 45 列

       0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i

      46 列から 50 列

       0.0000 + 0.0000i   0.0000 + 0.0000i  -0.4441 + 0.7771i   0.0000 + 0.0000i   0.0000 + 0.0000i

      51 列から 55 列

       0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i

      56 列から 60 列

       0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i

      61 列から 65 列

       0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0087 + 0.7018i   0.0000 + 0.0000i

      66 列から 70 列

       0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i

      71 列から 75 列

       0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i

      76 列から 80 列

       0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.2761 + 0.4565i

      81 列から 85 列

       0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i

      86 列から 90 列

       0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i

      91 列から 95 列

       0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i

      96 列から 100 列

      -0.3355 + 0.1977i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i

      101 列から 105 列

       0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i

      106 列から 110 列

       0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i

      111 列から 115 列

       0.0000 + 0.0000i  -0.1868 + 0.3364i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i

      116 列から 120 列

       0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i

    ...

A4のノコギリ波を入れてみた．

0でないところを取り出すために`findpeaks`してみる．

    >> [pks,locs] = findpeaks(abs(a4saw))

    pks =

       1.0e+04 *

        2.6755    1.1609    0.8951    0.7018    0.5335    0.3894    0.3847    0.3509    0.2954


    locs =

        16    32    48    64    80    96   112   128   144

A0の16倍音，32倍音，48倍音，…に値が入っていることが分かる．

つまり，A4の倍音成分が取り出せているのかな．
